## Παράρτημα Α: Λέξεις-κλειδιά


Η παρακάτω λίστα περιέχει λέξεις-κλειδιά που είναι δεσμευμένες για τωρινή ή
μελλοντική χρήση από τη γλώσσα Rust. Ως εκ τούτου, δε μπορούν να χρησιμοποιηθούν
ως αναγνωριστικά (εκτός από τη χρήση τους ως [πρωτογενή αναγνωριστικά][raw-identifiers]),
το οποίο συμπεριλαμβάνει ονόματα συναρτήσεων, μεταβλητών, παραμέτρων, πεδίων δομών,
τμημάτων, κιβωτίων, σταθερών, μακροεντολών, στατικών τιμών, γνωσιματων, τυπων,
χαρακτηριστικών, ή διαρκειών ζωής.

### Λέξεις-κλειδιά σε Χρήση Τώρα

Οι παρακάτω λέξεις-κλειδιά έχουν αυτή τη στιγμή περιγραφή λειτουργίας.

* `as` - εκτέλεση απλής μετατροπής, αποσαφήνιση του χαρακτηριστικού που
περιέχει ένα αντικείμενο, ή μετονομασία αντικειμένου σε προτάσεις `use`
ή `extern crate`
* `break` - άμεση έξοδος από βρόχο
* `const` - ορισμός σταθερού αντικειμένου ή δείκτη σε σταθερά
* `continue` - μετάβαση στην επόμενη επανάληψη του βρόχου
* `crate` - σύνδεση ενός εξωτερικού κιβωτίου ή μιας μεταβλητής μακροεντολής
που αναπαραιστά το κιβώτιο στο οποίο ορίζεται η μακροεντολή
* `dyn` - δυναμική κλήση σε χαρακτηριστικό
* `else` - εναλλακτική για εκφράσεις ελέγχου ροής `if` και `if let`
* `enum` - ορισμός μιας απαρίθμησης
* `extern` - σύνδεση ενός εξωτερικού κιβωτίου, συνάρτησης, ή μεταβλητής
* `false` - κυριολεκτικό λογικού «όχι»
* `fn` - ορισμός συνάρητσης ή ο τύπος δείκτη σε συνάρτηση
* `for` - δημιουργία βρόχου που ανατρέχει σε συλλογή, υλοποίηση ενος
χαρακτηριστικου, ή ορισμός μιας διάρκεις ζωής υψηλότερου βαθμού
* `if` - διακλάδωση ροής με βάση το αποτέλεσμα μιας έκφρασης συνθήκης
* `impl` - υλοποίηση εγγενούς λειτουργικότητας ή λειτουργικότητας
από χαρακτηριστικό
* `in` - μέρος του συντακτικού των βρόχων `for`
* `let` - ονοματοδοσία μεταβλητής
* `loop` - βρόχος χωρίς συνθήκη
* `match` - ταίριασμα τιμής με μοτίβα
* `mod` - ορισμός ενός τμήματος
* `move` - κλείσιμο που λαμβάνει κυριότητα των μεταβλητών που αιχμαλωτίζει
* `mut` - δήλωση μεταβλητότητας σε αναφορές, δείκτες, ή μοτίβα
* `pub` - δήλωση δημόσιας ορατότητας σε πεδία δομών, μπλοκ `impl`, ή τμήματα
* `ref` - ονοματοδοσία μέσω αναφοράς
* `return` - επιστροφή από συνάρτηση
* `Self` - ψευδώνυμο που αναφέρεται στον τύπο ο οποίος υλοποιεί ένα χαρακτηριστικό
* `self` - υποκείμενο μεθόδου ή το τρέχον τμήμα
* `static` - καθολική μεταβλητή ή διάρκεια ζωής που αντιστοιχεί σε ολόκληρη την εκτέλεση του προγράμματος
* `struct` - ορισμός μιας δομής
* `super` - γονεϊκό τμήμα του τρέχοντος τμήματος
* `trait` - ορισμός ενός χαρακτηριστικού
* `true` - κυριολεκτικό λογικού «ναι»
* `type` - ορισμός ενός ψευδωνύμου τύπου ή συσχετισμένου τύπου
* `unsafe` - δήλωση επισφαλούς κώδικα, συναρτήσεων, χαρακτηριστικών, ή υλοποιήσεων
* `use` - προσθήκη συμβόλων σε θέα
* `where` - δήλωση όρων που περιορίζουν έναν τύπο
* `while` - βρόχος υπό συνθήκη με βάση το αποτέλεσμα μιας έκφρασης συνθήκης

### Λέξεις-κλειδιά Δεσμευμένες για Μελλοντική Χρήση

Οι παρακάτω λέξεις δεν έχουν καμία λειτουργικότητα αλλά είναι δεσμευμένες από τη Rust
για πιθανή μελλοντική χρήση.

* `abstract`
* `async`
* `become`
* `box`
* `do`
* `final`
* `macro`
* `override`
* `priv`
* `try`
* `typeof`
* `unsized`
* `virtual`
* `yield`

### Πρωτογενή αναγνωριστικά
[raw-identifiers]: #raw-identifiers

Τα πρωτογενή αναγνωριστικά σας επιτρέπουν να χρησιμοποιήσετε λέξεις-κλειδιά σε σημεία όπου κανονικά δε θα μπορούσαν να χρησιμοποιηθούν, με χρήση του προθέματος `r#`.

Για παράδειγμα, το `match` είναι λέξη-κλειδί. Εάν επιχειρήσετε να μεταγλωττίσετε αυτή τη συνάρτηση:

```rust,ignore
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

Θα λάεβετε το εξής σφάλμα:

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

Μπορείτε όμως να τη γράψετε με χρήση πρωτογενούς αναγνωριστικού:

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

Προσέξτε το πρόθεμα `r#` τόσο στο όνομα της συνάρτησης όσο και στην κλήση.

#### Κίνητρο

Η δυνατότητα αυτή είναι χρήσιμη για κάποιους λόγους, αλλά το μεγαλύτερο κίνητρο ήταν οι καταστάσεις μετάβασης από έκδοση σε έκδοση. Για παράδειγμα, το `try` δεν είναι λέξη-κλειδή στην έκδοση 2015, αλλά είναι στην έκδοση 2018. Επομένως, εάν έχετε μια βιβλιοθήκη γραμμένη σε Rust του 2015 και η βιβλιοθήκη αυτή ορίζει μια συνάρητηση με όνομα `try`, για να κληθεί αυτή η συνάρτηση από κώδικα γραμμένο σε Rust του 2018 απαιτείται η χρήση του πρωτογενούς αναγνωριστικού.